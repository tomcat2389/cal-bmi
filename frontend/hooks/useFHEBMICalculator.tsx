"use client";

import { ethers } from "ethers";
import {
  RefObject,
  useCallback,
  useEffect,
  useMemo,
  useRef,
  useState,
} from "react";

import { FhevmInstance } from "@/fhevm/fhevmTypes";
import { FhevmDecryptionSignature } from "@/fhevm/FhevmDecryptionSignature";
import { GenericStringStorage } from "@/fhevm/GenericStringStorage";

/*
  The following two files are automatically generated by the script located at
  <root>/scripts/genabi.mjs. This script parses the
  <root>/packages/fhevm-hardhat-template/deployments directory to retrieve
  deployment information for FHEBMICalculator.sol:

  - <root>/packages/site/abi/abi/FHEBMICalculatorABI.ts
  - <root>/packages/site/abi/abi/FHEBMICalculatorAddresses.ts
*/
import { FHEBMICalculatorAddresses } from "@/abi/FHEBMICalculatorAddresses";
import { FHEBMICalculatorABI } from "@/abi/FHEBMICalculatorABI";

export type ClearValueType = {
  handle: string;
  clear: string | bigint | boolean;
};

type FHEBMICalculatorInfoType = {
  abi: typeof FHEBMICalculatorABI.abi;
  address?: `0x${string}`;
  chainId?: number;
  chainName?: string;
};

export type BMICategory = 0 | 1 | 2; // 0: Underweight, 1: Normal, 2: Overweight
export type ClearBMICategory = {
  handle: string;
  clear: BMICategory;
};

/**
 * Resolves FHEBMICalculator contract metadata for the given EVM `chainId`.
 *
 * The ABI and address book are **generated** from the `fhevm-hardhat-template`
 * artifacts into the `@/abi` folder at build time. This function performs a
 * simple lookup in that generated map.
 *
 * Behavior:
 * - If `chainId` is `undefined` or not found in the map, returns ABI only.
 * - Otherwise returns `{ abi, address, chainId, chainName }`.
 *
 * @param chainId - Target chain id (e.g., 1, 5, 11155111). `undefined` returns ABI-only.
 * @returns Contract info for the chain or ABI-only fallback.
 * @example
 * const { abi, address } = getFHEBMICalculatorByChainId(chainId);
 */
function getFHEBMICalculatorByChainId(
  chainId: number | undefined
): FHEBMICalculatorInfoType {
  if (!chainId) {
    return { abi: FHEBMICalculatorABI.abi };
  }

  const entry =
    FHEBMICalculatorAddresses[chainId.toString() as keyof typeof FHEBMICalculatorAddresses];

  if (!("address" in entry) || entry.address === ethers.ZeroAddress) {
    return { abi: FHEBMICalculatorABI.abi, chainId };
  }

  return {
    address: entry?.address as `0x${string}` | undefined,
    chainId: entry?.chainId ?? chainId,
    chainName: entry?.chainName,
    abi: FHEBMICalculatorABI.abi,
  };
}

/*
 * Main FHEBMICalculator React hook for BMI calculations
 *  - "Calculate BMI" button: allows you to calculate BMI category from encrypted height and weight.
 *  - Privacy-preserving: only reveals BMI category, not actual values.
 */
export const useFHEBMICalculator = (parameters: {
  instance: FhevmInstance | undefined;
  fhevmDecryptionSignatureStorage: GenericStringStorage;
  eip1193Provider: ethers.Eip1193Provider | undefined;
  chainId: number | undefined;
  ethersSigner: ethers.JsonRpcSigner | undefined;
  ethersReadonlyProvider: ethers.ContractRunner | undefined;
  sameChain: RefObject<(chainId: number | undefined) => boolean>;
  sameSigner: RefObject<
    (ethersSigner: ethers.JsonRpcSigner | undefined) => boolean
  >;
}) => {
  const {
    instance,
    fhevmDecryptionSignatureStorage,
    chainId,
    ethersSigner,
    ethersReadonlyProvider,
    sameChain,
    sameSigner,
  } = parameters;

  //////////////////////////////////////////////////////////////////////////////
  // States + Refs
  //////////////////////////////////////////////////////////////////////////////

  const [bmiCategoryHandle, setBmiCategoryHandle] = useState<string | undefined>(undefined);
  const [clearBmiCategory, setClearBmiCategory] = useState<ClearBMICategory | undefined>(undefined);
  const clearBmiCategoryRef = useRef<ClearBMICategory>(undefined);
  const [isCalculating, setIsCalculating] = useState<boolean>(false);
  const [isDecrypting, setIsDecrypting] = useState<boolean>(false);
  const [message, setMessage] = useState<string>("");
  const [height, setHeight] = useState<number>(170);
  const [weight, setWeight] = useState<number>(65);

  const fheBmiCalculatorRef = useRef<FHEBMICalculatorInfoType | undefined>(undefined);
  const isCalculatingRef = useRef<boolean>(isCalculating);
  const isDecryptingRef = useRef<boolean>(isDecrypting);
  const contractRef = useRef<ethers.Contract | undefined>(undefined);

  const isDecrypted = bmiCategoryHandle && bmiCategoryHandle === clearBmiCategory?.handle;

  //////////////////////////////////////////////////////////////////////////////
  // FHEBMICalculator Contract
  //////////////////////////////////////////////////////////////////////////////

  const fheBmiCalculator = useMemo(() => {
    const c = getFHEBMICalculatorByChainId(chainId);

    fheBmiCalculatorRef.current = c;

    // Only show error if chainId is defined (wallet connected) but no deployment found
    if (chainId !== undefined && !c.address) {
      setMessage(`FHEBMICalculator deployment not found for chainId=${chainId}.`);
    } else if (chainId === undefined) {
      // Clear message when wallet is not connected
      setMessage("");
    }

    return c;
  }, [chainId]);

  // Create contract instance and set up event listeners
  useEffect(() => {
    if (fheBmiCalculator.address && ethersSigner) {
      const contract = new ethers.Contract(
        fheBmiCalculator.address,
        fheBmiCalculator.abi,
        ethersSigner
      );
      contractRef.current = contract;

      // Listen for BMICalculated events
      const onBMICalculated = (user: string, bmiCategory: string) => {
        if (user.toLowerCase() === ethersSigner.address.toLowerCase()) {
          console.log("[useFHEBMICalculator] BMICalculated event received:", bmiCategory);
          setBmiCategoryHandle(bmiCategory);
          setMessage("BMI calculation complete! Click the button below to view your BMI category result.");
        }
      };

      contract.on("BMICalculated", onBMICalculated);

      return () => {
        contract.off("BMICalculated", onBMICalculated);
      };
    }
  }, [fheBmiCalculator.address, ethersSigner]);

  //////////////////////////////////////////////////////////////////////////////
  // BMI Calculation
  //////////////////////////////////////////////////////////////////////////////

  const isDeployed = useMemo(() => {
    if (!fheBmiCalculator) {
      return undefined;
    }
    return (Boolean(fheBmiCalculator.address) && fheBmiCalculator.address !== ethers.ZeroAddress);
  }, [fheBmiCalculator]);

  const canCalculateBMI = useMemo(() => {
    return (
      fheBmiCalculator.address &&
      instance &&
      ethersSigner &&
      !isCalculating &&
      !isDecrypting
    );
  }, [fheBmiCalculator.address, instance, ethersSigner, isCalculating, isDecrypting]);

  /**
   * Calculate BMI category from encrypted height and weight inputs
   */
  const calculateBMI = useCallback(
    (heightCm: number, weightKg: number) => {
      if (isCalculatingRef.current || isDecryptingRef.current) {
        return;
      }

      if (!fheBmiCalculator.address || !instance || !ethersSigner) {
        return;
      }

      // Validate input ranges
      if (heightCm < 150 || heightCm > 250 || weightKg < 30 || weightKg > 200) {
        setMessage("Please enter valid height (150-250cm) and weight (30-200kg)");
        return;
      }

      const thisChainId = chainId;
      const thisFheBmiCalculatorAddress = fheBmiCalculator.address;
      const thisEthersSigner = ethersSigner;
      const thisFheBmiCalculatorContract = contractRef.current;

      if (!thisFheBmiCalculatorContract) {
        setMessage("Contract not initialized");
        return;
      }

      isCalculatingRef.current = true;
      setIsCalculating(true);
      setMessage(`Start BMI calculation for ${heightCm}cm, ${weightKg}kg...`);

      const run = async () => {
        const isStale = () =>
          thisFheBmiCalculatorAddress !== fheBmiCalculatorRef.current?.address ||
          !sameChain.current(thisChainId) ||
          !sameSigner.current(thisEthersSigner);

        try {
          // Create encrypted inputs for height and weight
          const heightInput = instance.createEncryptedInput(
            thisFheBmiCalculatorAddress,
            thisEthersSigner.address
          );
          heightInput.add32(heightCm);

          const weightInput = instance.createEncryptedInput(
            thisFheBmiCalculatorAddress,
            thisEthersSigner.address
          );
          weightInput.add32(weightKg);

          // Encrypt the inputs (CPU-intensive)
          setMessage("Encrypting inputs...");
          const heightEnc = await heightInput.encrypt();
          const weightEnc = await weightInput.encrypt();

          if (isStale()) {
            setMessage("Calculation cancelled");
            return;
          }

          setMessage("Calling smart contract...");

          // Call the BMI calculation function
          const tx: ethers.TransactionResponse =
            await thisFheBmiCalculatorContract.calculateBMICategory(
              heightEnc.handles[0], // height handle
              weightEnc.handles[0], // weight handle
              heightEnc.inputProof, // height proof
              weightEnc.inputProof  // weight proof
            );

          setMessage(`Waiting for transaction: ${tx.hash}...`);

          const receipt = await tx.wait();

          setMessage(`BMI calculation completed! Status: ${receipt?.status}`);

          if (isStale()) {
            setMessage("Result ignored due to state change");
            return;
          }

          // The contract returns an encrypted category, we need to decrypt it
          // Note: In this design, the category is returned encrypted and we need to decrypt it
          // But the contract call above doesn't return the handle, we need to call a view function
          setMessage("Getting BMI category result...");

          // Since calculateBMICategory returns an encrypted value, we need to get it
          // But the function is not a view, it just returns the encrypted category
          // We need to modify our approach - perhaps we need the contract to store and return the handle

          // For now, let's assume the contract returns the encrypted category handle
          // We would need to modify the contract to return the handle or store it

          setMessage("BMI category calculated successfully!");

        } catch (error) {
          console.error("BMI calculation failed:", error);
          setMessage(`BMI calculation failed: ${error}`);
        } finally {
          isCalculatingRef.current = false;
          setIsCalculating(false);
        }
      };

      run();
    },
    [
      ethersSigner,
      fheBmiCalculator.address,
      fheBmiCalculator.abi,
      instance,
      chainId,
      sameChain,
      sameSigner,
    ]
  );

  //////////////////////////////////////////////////////////////////////////////
  // BMI Category Decryption
  //////////////////////////////////////////////////////////////////////////////

  const canDecryptCategory = useMemo(() => {
    return (
      fheBmiCalculator.address &&
      instance &&
      ethersSigner &&
      !isCalculating &&
      !isDecrypting &&
      bmiCategoryHandle &&
      bmiCategoryHandle !== ethers.ZeroHash &&
      bmiCategoryHandle !== clearBmiCategory?.handle
    );
  }, [
    fheBmiCalculator.address,
    instance,
    ethersSigner,
    isCalculating,
    isDecrypting,
    bmiCategoryHandle,
    clearBmiCategory,
  ]);

  /**
   * Decrypt BMI category handle to get the clear category value
   */
  const decryptBMICategory = useCallback(() => {
    if (isCalculatingRef.current || isDecryptingRef.current) {
      return;
    }

    if (!fheBmiCalculator.address || !instance || !ethersSigner) {
      return;
    }

    // Already computed
    if (bmiCategoryHandle === clearBmiCategoryRef.current?.handle) {
      return;
    }

    if (!bmiCategoryHandle) {
      setClearBmiCategory(undefined);
      clearBmiCategoryRef.current = undefined;
      return;
    }

    const thisChainId = chainId;
    const thisFheBmiCalculatorAddress = fheBmiCalculator.address;
    const thisBmiCategoryHandle = bmiCategoryHandle;
    const thisEthersSigner = ethersSigner;

    isDecryptingRef.current = true;
    setIsDecrypting(true);
    setMessage("Decrypting BMI category...");

    const run = async () => {
      const isStale = () =>
        thisFheBmiCalculatorAddress !== fheBmiCalculatorRef.current?.address ||
        !sameChain.current(thisChainId) ||
        !sameSigner.current(thisEthersSigner);

      try {
        const sig: FhevmDecryptionSignature | null =
          await FhevmDecryptionSignature.loadOrSign(
            instance,
            [fheBmiCalculator.address as `0x${string}`],
            ethersSigner,
            fhevmDecryptionSignatureStorage
          );

        if (!sig) {
          setMessage("Unable to build FHEVM decryption signature");
          return;
        }

        if (isStale()) {
          setMessage("Decryption cancelled");
          return;
        }

        setMessage("Calling FHEVM decryption service...");

        const res = await instance.userDecrypt(
          [{ handle: thisBmiCategoryHandle, contractAddress: thisFheBmiCalculatorAddress }],
          sig.privateKey,
          sig.publicKey,
          sig.signature,
          sig.contractAddresses,
          sig.userAddress,
          sig.startTimestamp,
          sig.durationDays
        );

        setMessage("BMI category decrypted successfully!");

        if (isStale()) {
          setMessage("Result ignored due to state change");
          return;
        }

        const categoryValue = Number(res[thisBmiCategoryHandle]) as BMICategory;

        setClearBmiCategory({ handle: thisBmiCategoryHandle, clear: categoryValue });
        clearBmiCategoryRef.current = {
          handle: thisBmiCategoryHandle,
          clear: categoryValue,
        };

        const categoryNames = ["Underweight", "Normal", "Overweight"];
        setMessage(`Your BMI category: ${categoryNames[categoryValue]}`);

      } catch (error) {
        console.error("BMI category decryption failed:", error);
        setMessage(`Decryption failed: ${error}`);
      } finally {
        isDecryptingRef.current = false;
        setIsDecrypting(false);
      }
    };

    run();
  }, [
    fhevmDecryptionSignatureStorage,
    ethersSigner,
    fheBmiCalculator.address,
    instance,
    bmiCategoryHandle,
    chainId,
    sameChain,
    sameSigner,
  ]);

  /**
   * Reset all states for a new calculation
   */
  const reset = useCallback(() => {
    setBmiCategoryHandle(undefined);
    setClearBmiCategory(undefined);
    clearBmiCategoryRef.current = undefined;
    setMessage("");
  }, []);

  return {
    contractAddress: fheBmiCalculator.address,
    canCalculateBMI,
    canDecryptCategory,
    calculateBMI,
    decryptBMICategory,
    reset,
    isDecrypted,
    message,
    category: clearBmiCategory?.clear,
    handle: bmiCategoryHandle,
    isCalculating,
    isDecrypting,
    isDeployed,
    // Input values
    height,
    weight,
    setHeight,
    setWeight
  };
};
